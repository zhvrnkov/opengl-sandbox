* opengl-tutorial.com
The opengl-tutorial.com is really stupid. Going to another.
** tutorial2
*** shaders
there is two shaders -- frag and vert

- vertex shader will be executed for each vertex
- fragment shader will be executed for each sample

**** shader code
in openGL shaders are written in GLSL: GL Shader Language

shaders are compiled at run time

*** entities
**** what is vertex?
vertex is a 3D point -- have X, Y and Z coordinates

comes from vertices

triangle consists of 3 vertexs

rect consists of 4 vertexs
***** TODO questions
- can 2D ogl program can be written without Z coordinate? so the vertex in this case will have 2 coordinates
- what is 'layout(location = 0)'. in tutorial author said that this should match to some number in c code.
  maybe this value should match to first arg of glVertexAttribPointer which is 0. but no luck.
- vertex shader have some input (vec3). is this input passed from c code?
- are shaders computed on GPU?
- how to pass data to shader?


**** what is fragment?

* learnopengl.com
https://learnopengl.com/
** TODO Hello Triangle
- vertex is collection of data per 3D coordinate. It's not just its position, but also its color and etc
- fragment is all the required data for rendering one pixel
- you pass only normalized coordinates (in range -1..1) -- otherwise the image will be clipped. during the pipeline you normalized coordinates will be translated to screen-space coordinates
- forth parameter of glBufferData. (GL_STATIC_DRAW and etc) determine where the VBO will be placed (in "fast", "medium" or "slow" memory). If GL_DYNAMIC_DRAW, then obviously, VBO should be placed in "fast" memory

*** pipeline
**** vertex shader
for transforming vertex to (another) vertex. for example from one coordinate system to other
**** TODO shape assembly
takes all vertices from *vertex shader* and form a primitive (depends on type of draw: GL_POINT, GL_TRIANGLE...) and assemble all the points
**** TODO geometry shader
takes all assembled vertices from previous shader and *has the ability* to generate other shapes (divide one triangle into two)
**** rasterization
it gets final geometric shape from previous shaders and *maps this to corresponding pixels on the final screen* resulting in fragments to output to next shader
**** fragment shader
calculating color of each pixel (lights, shadows, color of the light and etc)
**** tests and blending
as I understand, it checks the whole "picture" by combining multiple primitives which can overlap each other. so you got two shapes -- one red one blue and they have same pixel. which color this pixel will be (red or blue) is determined on this stage

*** TODO scheme
1. setup ogl
2. load shaders:
   get shaders sources
   compile shaders sources
   link shader sources
3. create VBO
   tell ogl to generate buffer
   it returns buffer ID
   bind buffer to specific type (GL_ARRAY_BUFFER)
4. compute coordinates on CPU
5. fill VBO with values
6. pass VBO to GPU
7. VBO is an array of "contexts". Each context is a data input for pipeline (vertex shader)
8. GPU launch as many pipelines as needed (or specified) for each context
   in case of triangle it seems like there is one pipeline (because one context -- 3 vertices). If each vertex will be a context, then what shaders after vertex shader should do with that point? So there is one pipeline because of it
9. GPU is done --> outputing data to display?

*** linkage
#+BEGIN_QUOTE
When linking the shaders into a program it links the *outputs* of each shader to the *inputs* of the next shader
#+END_QUOTE
 
*** TODO vbo
- glVertexAttribPointer call is associated with VBO, which were bound to GL_ARRAY_BUFFER

**** how to setup VBO
1. gen buffer (glGenBuffers)
2. bind buffer to Vertex Buffer Object type (glBindBuffer)
3. describe buffer by calling glVertexAttribPointer
4. set data to buffer (glBufferData)
5. enable buffer (glEnableVertexAttribArray)

**** DONE how to setup multiple VBOs?
What I want to know, is how to pass two (more than one) vec3 to vertex shader?

**** TODO pass mat3 to vertex and perform vec3 * mat3 in shader

**** TODO multiple locations (attributes) in single VBO?

**** TODO two shapes with different color
for this you need to pass data to fragment shader

**** STARTED why is there color gradient in rounded square?
I thought that in case of triangle:
- vertex shader is called three times (for each vertex)
- fragment shader is called once (for single shape)

But it turns out that there is a color gradient. So the question is why it's here?

Also notice that fragment shader takes paramenter from vertex shader, but if vertex shader called 3 times, and fragment shader calls N times (> 3), then from who fragment shader takes this input arg?
 
***** answer
fragment shader isn't recieve input from vertex shader, because after vertex shader there is geometry shader -- this is my thought.

^ this is first reason -- fragment shader will be called more then 3 times in triangle. 

It will be called N times, where N is number of fragments which is calculated at rasterization stage.

Also, the reason of gradient is called *fragment interpolation* -- output of vertex shaders (color in this case) (3 vectors) is strectched linearly by rasterizator.

*** DONE vao
VAO is like bindings manager. VAO is proxy to VBO and EBO. OpenGL connects to VAO and get VBO and EBO from it.

*** TODO questions
- what is buffer type? and why ogl needs it
- in frag shader we declare the `out` parameter, but didn't do it for vert shader? why?

  
** Shaders
*** vec syntax
#+begin_src
vec3 vector;
vec2 vector1 = vector.xx;
vec4 vector2 = vector.xxyy;
#+end_src

#+begin_src
vec3 vector;
vec4 vector1 = vec4(vector, 1);
#+end_src
*** in and out
There are two requirements if you want to pass something from one shader to another:
- same type
- same name

*** uniform
- scoped to whole program (any shader can access them)
- can be reseted or updated

**** how to use?
#+name shader
#+begin_src glsl
...
uniform <type> <name>;
...
#+end_src

#+name code
#+begin_src c
...
int location = glGetUniformLocation(program, "<name>");
glUseProgram(program);
glUniform<type>(location, values...);
...
#+end_src

*** TODO fragment interpolation 
Can it be changed? For example I want it to behave differently (not stretch colors, but just fill 1/3 of shape with vertex color) -- how to achieve this?
